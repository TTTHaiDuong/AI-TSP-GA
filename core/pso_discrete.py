"""
Discrete Particle Swarm Optimization (PSO) for Traveling Salesman Problem (TSP)
Using Swap Operators for direct permutation manipulation

The Discrete PSO approach works by:
1. Each particle has a direct permutation (tour) as position
2. Velocity is represented as a sequence of swap operations
3. Swap operators exchange two cities in the tour
4. Velocity is generated by finding swaps needed to transform one tour to another

This is a more natural representation for TSP compared to continuous PSO.
"""

import random
import math


class SwapOperator:
    """Represents a swap operation between two positions"""
    
    def __init__(self, i, j):
        """
        Create a swap operator
        
        Args:
            i: First position index
            j: Second position index
        """
        self.i = i
        self.j = j
    
    def apply(self, tour):
        """
        Apply swap to a tour (in-place)
        
        Args:
            tour: List representing tour
        """
        tour[self.i], tour[self.j] = tour[self.j], tour[self.i]
    
    def __repr__(self):
        return f"Swap({self.i}, {self.j})"
    
    def __eq__(self, other):
        if not isinstance(other, SwapOperator):
            return False
        return (self.i == other.i and self.j == other.j) or \
               (self.i == other.j and self.j == other.i)
    
    def __hash__(self):
        return hash((min(self.i, self.j), max(self.i, self.j)))


class DiscreteParticle:
    """Represents a single particle in discrete PSO"""
    
    def __init__(self, n_cities):
        """
        Initialize a particle with random tour
        
        Args:
            n_cities: Number of cities in TSP
        """
        self.n_cities = n_cities
        # Position: direct permutation (tour)
        self.position = list(range(n_cities))
        random.shuffle(self.position)
        
        # Velocity: sequence of swap operators
        self.velocity = []
        
        # Personal best
        self.pbest_position = self.position[:]
        self.pbest_fitness = float('inf')
        
        # Current fitness
        self.fitness = float('inf')
    
    def get_tour(self):
        """Get current tour (position is already a tour)"""
        return self.position[:]
    
    def apply_velocity(self):
        """Apply velocity (swap sequence) to position"""
        for swap in self.velocity:
            swap.apply(self.position)
    
    def update_velocity(self, gbest_position, w, c1, c2, max_swaps=None):
        """
        Update particle velocity using discrete PSO formula
        
        Args:
            gbest_position: Global best position (tour)
            w: Inertia weight (probability of keeping current velocity)
            c1: Cognitive coefficient (influence of personal best)
            c2: Social coefficient (influence of global best)
            max_swaps: Maximum number of swaps in velocity
        """
        new_velocity = []
        
        # 1. Inertia component: Keep some swaps from current velocity
        if self.velocity and random.random() < w:
            n_keep = max(1, int(len(self.velocity) * w))
            new_velocity.extend(random.sample(self.velocity, min(n_keep, len(self.velocity))))
        
        # 2. Cognitive component: Swaps to move toward personal best
        if random.random() < c1:
            cognitive_swaps = self._get_swap_sequence(self.position, self.pbest_position)
            n_cognitive = max(1, int(len(cognitive_swaps) * c1))
            new_velocity.extend(random.sample(cognitive_swaps, min(n_cognitive, len(cognitive_swaps))))
        
        # 3. Social component: Swaps to move toward global best
        if random.random() < c2:
            social_swaps = self._get_swap_sequence(self.position, gbest_position)
            n_social = max(1, int(len(social_swaps) * c2))
            new_velocity.extend(random.sample(social_swaps, min(n_social, len(social_swaps))))
        
        # Remove duplicate swaps (keep unique)
        new_velocity = list(dict.fromkeys(new_velocity))
        
        # Apply velocity clamping
        if max_swaps is not None and len(new_velocity) > max_swaps:
            new_velocity = random.sample(new_velocity, max_swaps)
        
        self.velocity = new_velocity
    
    def _get_swap_sequence(self, from_tour, to_tour):
        """
        Find sequence of swaps to transform from_tour into to_tour
        
        Args:
            from_tour: Source tour
            to_tour: Target tour
            
        Returns:
            List of SwapOperator objects
        """
        swaps = []
        temp_tour = from_tour[:]
        
        for i in range(len(temp_tour)):
            if temp_tour[i] != to_tour[i]:
                # Find where the correct city is
                target_city = to_tour[i]
                j = temp_tour.index(target_city)
                
                # Create swap to move it to correct position
                if i != j:
                    swaps.append(SwapOperator(i, j))
                    # Apply swap to temp tour
                    temp_tour[i], temp_tour[j] = temp_tour[j], temp_tour[i]
        
        return swaps


class DiscretePSO:
    """Discrete Particle Swarm Optimization for TSP using Swap Operators"""
    
    def __init__(self, cities, swarm_size=30, inertia_weight=0.7, 
                 cognitive_coef=0.8, social_coef=0.8,
                 max_swaps=None, max_iterations=100):
        """
        Initialize Discrete PSO algorithm
        
        Args:
            cities: List of city coordinates [(x1, y1), (x2, y2), ...] or [{"x": x1, "y": y1}, ...]
            swarm_size: Number of particles in swarm
            inertia_weight: Inertia weight (w) - probability of keeping velocity
            cognitive_coef: Cognitive coefficient (c1) - personal best influence
            social_coef: Social coefficient (c2) - global best influence
            max_swaps: Maximum number of swaps in velocity (None for no limit)
            max_iterations: Maximum number of iterations
        """
        # Convert cities to tuple format if dict format
        if cities and isinstance(cities[0], dict):
            self.cities = [(city["x"], city["y"]) for city in cities]
        else:
            self.cities = cities
            
        self.n_cities = len(self.cities)
        self.swarm_size = swarm_size
        self.w = inertia_weight
        self.c1 = cognitive_coef
        self.c2 = social_coef
        self.max_swaps = max_swaps if max_swaps else self.n_cities
        self.max_iterations = max_iterations
        
        # Initialize swarm
        self.swarm = [DiscreteParticle(self.n_cities) 
                     for _ in range(self.swarm_size)]
        
        # Global best
        self.gbest_position = None
        self.gbest_fitness = float('inf')
        self.gbest_tour = None
        
        # History for tracking convergence
        self.fitness_history = []
    
    def calculate_distance(self, city1_idx, city2_idx):
        """Calculate Euclidean distance between two cities"""
        x1, y1 = self.cities[city1_idx]
        x2, y2 = self.cities[city2_idx]
        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    
    def calculate_tour_distance(self, tour):
        """Calculate total distance of a tour"""
        total_distance = 0.0
        for i in range(len(tour)):
            city1 = tour[i]
            city2 = tour[(i + 1) % len(tour)]  # Wrap around to first city
            total_distance += self.calculate_distance(city1, city2)
        return total_distance
    
    def evaluate_particle(self, particle):
        """Evaluate fitness of a particle"""
        tour = particle.get_tour()
        fitness = self.calculate_tour_distance(tour)
        return fitness, tour
    
    def optimize(self):
        """
        Run Discrete PSO optimization
        
        Returns:
            best_tour: List of city indices representing best tour found
        """
        # Initial evaluation
        for particle in self.swarm:
            fitness, tour = self.evaluate_particle(particle)
            particle.fitness = fitness
            
            # Update personal best
            if fitness < particle.pbest_fitness:
                particle.pbest_fitness = fitness
                particle.pbest_position = particle.position[:]
            
            # Update global best
            if fitness < self.gbest_fitness:
                self.gbest_fitness = fitness
                self.gbest_position = particle.position[:]
                self.gbest_tour = tour
        
        self.fitness_history.append(self.gbest_fitness)
        
        # Main PSO loop
        for iteration in range(self.max_iterations):
            for particle in self.swarm:
                # Update velocity
                particle.update_velocity(self.gbest_position, self.w, 
                                       self.c1, self.c2, self.max_swaps)
                
                # Apply velocity to update position
                particle.apply_velocity()
                
                # Evaluate new position
                fitness, tour = self.evaluate_particle(particle)
                particle.fitness = fitness
                
                # Update personal best
                if fitness < particle.pbest_fitness:
                    particle.pbest_fitness = fitness
                    particle.pbest_position = particle.position[:]
                
                # Update global best
                if fitness < self.gbest_fitness:
                    self.gbest_fitness = fitness
                    self.gbest_position = particle.position[:]
                    self.gbest_tour = tour
            
            # Record fitness history
            self.fitness_history.append(self.gbest_fitness)
        
        return self.gbest_tour
    
    def get_best_distance(self):
        """Get the distance of the best tour found"""
        return self.gbest_fitness
    
    def get_fitness_history(self):
        """Get fitness history for plotting convergence"""
        return self.fitness_history


def solve_tsp_discrete_pso(cities, swarm_size=30, inertia_weight=0.7,
                           cognitive_coef=0.8, social_coef=0.8,
                           max_swaps=None, max_iterations=100):
    """
    Convenience function to solve TSP using Discrete PSO
    
    Args:
        cities: List of city coordinates [(x1, y1), (x2, y2), ...] or [{"x": x1, "y": y1}, ...]
        swarm_size: Number of particles
        inertia_weight: Inertia weight (w)
        cognitive_coef: Cognitive coefficient (c1)
        social_coef: Social coefficient (c2)
        max_swaps: Maximum number of swaps in velocity
        max_iterations: Number of iterations
    
    Returns:
        best_tour: List of city indices representing best tour
    """
    pso = DiscretePSO(cities, swarm_size, inertia_weight,
                     cognitive_coef, social_coef, max_swaps, max_iterations)
    best_tour = pso.optimize()
    return best_tour
